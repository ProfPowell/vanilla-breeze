---
layout: layouts/attribute.njk
title: "hide-until-ready / show-until-ready"
description: "CSS utility attributes for FOUC prevention. Hide custom elements until defined, or show placeholder content that disappears when the component is ready."
attributeName: hide-until-ready
category: infrastructure
currentPath: /docs/attributes/hide-until-ready/
permalink: /docs/attributes/hide-until-ready/
---

{% set hideCode %}<!-- Hidden until the custom element is defined -->
<my-component hide-until-ready>
  Content that should only show when the component is ready.
</my-component>{% endset %}

{% set showCode %}<!-- Shown until the custom element is defined, then hidden -->
<my-component show-until-ready>
  Loading placeholder...
</my-component>

<my-component>
  Actual component content.
</my-component>{% endset %}

{% set combinedCode %}<!-- Loading skeleton shown until component is ready -->
<card-wc show-until-ready>
  <div class="skeleton" style="height: 200px;"></div>
</card-wc>

<!-- Real component hidden until defined -->
<card-wc hide-until-ready>
  <h3>Card Title</h3>
  <p>Card content loads without a flash of unstyled markup.</p>
</card-wc>{% endset %}

{% set cssCode %}/* How it works â€” pure CSS, no JavaScript needed */

[hide-until-ready]:not(:defined) \{
  display: none;
\}

[show-until-ready]:defined \{
  display: none;
\}{% endset %}

{% set realWorldCode %}<!-- Prevent FOUC on a dialog component -->
<dialog-wc hide-until-ready trigger="open-settings">
  <h2 slot="heading">Settings</h2>
  <p>Dialog content here.</p>
</dialog-wc>

<!-- Prevent layout shift on a tabs component -->
<tab-group hide-until-ready>
  <tab-panel label="First">Panel 1 content</tab-panel>
  <tab-panel label="Second">Panel 2 content</tab-panel>
</tab-group>{% endset %}

{% set placeholderCode %}<!-- Show a lightweight placeholder until the heavy component loads -->
<chart-wc show-until-ready>
  <p>Loading chart...</p>
</chart-wc>

<chart-wc hide-until-ready data-src="/api/chart-data">
  <!-- Full chart renders here once the element is defined -->
</chart-wc>{% endset %}

<section>
    <h2>Overview</h2>
    <p>Custom elements go through a brief undefined state before their JavaScript loads and registers them. During this window, the browser renders their raw HTML content, causing a <strong>flash of unstyled content (FOUC)</strong>. The <code>hide-until-ready</code> and <code>show-until-ready</code> attributes solve this with pure CSS &mdash; no JavaScript needed.</p>

    <ul>
      <li><code>hide-until-ready</code> &mdash; hides the element until its custom element is defined</li>
      <li><code>show-until-ready</code> &mdash; shows the element only while its custom element is undefined (placeholder content)</li>
    </ul>
  </section>

  <section>
    <h2>How It Works</h2>
    <p>These attributes use the CSS <code>:defined</code> pseudo-class, which matches elements that have been registered via <code>customElements.define()</code>. The CSS rules are simple:</p>

    <code-block language="css" show-lines label="The complete CSS">{{ cssCode | safe }}</code-block>

    <p>Because this is pure CSS evaluated by the browser's style engine, it works immediately &mdash; before any JavaScript runs. There is no flicker or timing issue.</p>

    <h3>The :defined Pseudo-Class</h3>
    <p>The <code>:defined</code> pseudo-class matches any element that is defined. For custom elements (elements with a hyphen in their tag name), this means <code>customElements.define()</code> has been called for that tag. Standard HTML elements are always <code>:defined</code>.</p>

    <ul>
      <li><code>:not(:defined)</code> &mdash; matches custom elements before their class is registered</li>
      <li><code>:defined</code> &mdash; matches custom elements after registration, and all standard HTML elements always</li>
    </ul>
  </section>

  <section>
    <h2>hide-until-ready</h2>
    <p>Add <code>hide-until-ready</code> to any custom element to prevent it from rendering until its definition is loaded. The element is set to <code>display: none</code> while undefined, then automatically appears once the browser registers the custom element.</p>

    <code-block language="html" show-lines label="Hide until defined">{{ hideCode | safe }}</code-block>

    <p>This is the most common use case. It prevents raw, unstyled content from flashing before the component's styles and behavior are applied.</p>
  </section>

  <section>
    <h2>show-until-ready</h2>
    <p>Add <code>show-until-ready</code> to an element to display it only while the custom element is undefined. Once the element is defined, it disappears. This is useful for loading placeholders, skeleton screens, or fallback content.</p>

    <code-block language="html" show-lines label="Placeholder content">{{ showCode | safe }}</code-block>

    <p>The placeholder element uses the same tag name as the real component so that <code>:defined</code> triggers at the right time. When the custom element class is registered, all elements with that tag become <code>:defined</code> simultaneously.</p>
  </section>

  <section>
    <h2>Combined Pattern</h2>
    <p>Use both attributes together for a smooth loading experience: show a skeleton or placeholder while the component loads, then swap to the real content.</p>

    <code-block language="html" show-lines label="Skeleton to component swap">{{ combinedCode | safe }}</code-block>

    <p>This pattern ensures the user always sees something meaningful &mdash; a placeholder while loading, then the real component once ready. No layout shift, no flash of raw markup.</p>
  </section>

  <section>
    <h2>Common Use Cases</h2>

    <h3>Preventing FOUC on Complex Components</h3>
    <p>Components like dialogs, tab groups, and accordions often render incorrectly before their JavaScript initializes. Use <code>hide-until-ready</code> to avoid showing broken layouts:</p>

    <code-block language="html" show-lines label="FOUC prevention on components">{{ realWorldCode | safe }}</code-block>

    <h3>Loading Placeholders</h3>
    <p>For components that may take time to load (charts, maps, heavy widgets), show lightweight placeholder content:</p>

    <code-block language="html" show-lines label="Loading placeholder pattern">{{ placeholderCode | safe }}</code-block>
  </section>

  <section>
    <h2>Accessibility</h2>
    <ul>
      <li>Content hidden with <code>display: none</code> is removed from the accessibility tree &mdash; screen readers will not announce it</li>
      <li>When the component becomes defined, it appears in the accessibility tree automatically</li>
      <li>Placeholder content (<code>show-until-ready</code>) is accessible while visible, providing context during loading</li>
      <li>No JavaScript dependency &mdash; if scripts fail to load, <code>hide-until-ready</code> elements stay hidden (graceful degradation), while <code>show-until-ready</code> placeholders remain visible as fallback</li>
      <li>No ARIA attributes needed &mdash; the browser's native rendering handles visibility</li>
    </ul>
  </section>
